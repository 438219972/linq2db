<#@ assembly name="System.Core"                              #>
<#@ import namespace="System"                                #>
<#@ import namespace="System.Text"                           #>
<#@ import namespace="System.Collections.Generic"            #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Linq"                           #>
<#+
static Action<GeneratedTextTransformation,string> WriteComment    = (tt,s) => tt.WriteLine("//{0}", s);

Action BeforeGenerateModel = () => {};

bool GenerateProcedureErrors = true;

static Func<GeneratedTextTransformation, IRenderer> CreateRenderer = CreateSharpRenderer;

void GenerateModel()
{
	Model.SetTree();

	BeforeGenerateModel();

	CreateRenderer(this).Render(Model);
}

static Action<BaseRenderer,string> WriteUsing;

static IRenderer CreateSharpRenderer(GeneratedTextTransformation tt)
{
	var renderer = new CSharpRenderer(tt);

	renderer.WriteUsing          = WriteUsing          ?? renderer.WriteUsing;
	renderer.WriteBeginNamespace = WriteBeginNamespace ?? renderer.WriteBeginNamespace;
	renderer.WriteEndNamespace   = WriteEndNamespace   ?? renderer.WriteEndNamespace;
	renderer.WriteAttribute      = WriteAttribute      ?? renderer.WriteAttribute;
	renderer.WriteBeginClass     = WriteBeginClass     ?? renderer.WriteBeginClass;
	renderer.WriteEndClass       = WriteEndClass       ?? renderer.WriteEndClass;
	renderer.WriteEvent          = WriteEvent          ?? renderer.WriteEvent;
	renderer.WriteProperty       = WriteProperty       ?? renderer.WriteProperty;
	renderer.WriteMethod         = WriteMethod         ?? renderer.WriteMethod;
	renderer.BeginRegion         = BeginRegion         ?? renderer.BeginRegion;
	renderer.EndRegion           = EndRegion           ?? renderer.EndRegion;

	return renderer;
}

// Base data types.
//
public interface ITree
{
	ITree              Parent { get; set; }
	IEnumerable<ITree> GetNodes();
	void               SetTree();
}

ModelSource Model = new ModelSource();

public partial class ModelSource : ITree
{
	public int CurrentNamespace = 0;

	public List<string>    Usings     = new List<String>    { "System"        };
	public List<Namespace> Namespaces = new List<Namespace> { new Namespace() };

	public Namespace      Namespace { get { return Namespaces[CurrentNamespace];       } }
	public List<TypeBase> Types     { get { return Namespaces[CurrentNamespace].Types; } }

	public ITree              Parent     { get; set; }
	public IEnumerable<ITree> GetNodes() { return Namespaces; }

	public void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

static Action<BaseRenderer,string> WriteBeginNamespace;
static Action<BaseRenderer>        WriteEndNamespace;

public partial class Namespace : ITree
{
	public string         Name;
	public List<TypeBase> Types  = new List<TypeBase>();
	public List<string>   Usings = new List<string>();

	public ITree              Parent     { get; set; }
	public IEnumerable<ITree> GetNodes() { return Types; }

	public void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

public interface IClassMember : ITree
{
}

public enum AccessModifier
{
	Public,
	Protected,
	Internal,
	Private,
	Partial
}

public abstract partial class TypeBase : IClassMember
{
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public bool            IsPartial  = true;
	public List<string>    Comment    = new List<string>();
	public List<Attribute> Attributes = new List<Attribute>();
	public string          Conditional;

	public          ITree              Parent { get; set; }
	public abstract IEnumerable<ITree> GetNodes();
	public abstract void               SetTree ();
}

static Action<BaseRenderer, Class> WriteBeginClass;
static Action<BaseRenderer>        WriteEndClass;

public partial class Class : TypeBase
{
	public string             BaseClass;
	public bool               IsStatic   = false;
	public List<string>       Interfaces = new List<string>();
	public List<IClassMember> Members    = new List<IClassMember>();

	public Class()
	{
	}

	public Class(string name, params IClassMember[] members)
	{
		Name = name;
		Members.AddRange(members);
	}

	public override IEnumerable<ITree> GetNodes()
	{
		return Members;
	}

	public override void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

public abstract partial class MemberBase : IClassMember
{
	public string          ID;
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public string          Type;
	public List<string>    Comment = new List<string>();
	public string          EndLineComment;
	public List<Attribute> Attributes = new List<Attribute>();
	public bool            InsertBlankLineAfter = true;
	public string          Conditional;

	public int AccessModifierLen;
	public int ModifierLen;
	public int TypeLen;
	public int NameLen;
	public int ParamLen;
	public int BodyLen;

	public         ITree              Parent     { get; set; }
	public virtual IEnumerable<ITree> GetNodes() { return Enumerable.Empty<ITree>(); }
	public virtual void               SetTree () {}
}

static Action<BaseRenderer,string> BeginRegion;
static Action<BaseRenderer>        EndRegion;

public partial class MemberGroup : MemberBase
{
	public string             Region;
	public bool               IsCompact;
	public bool               IsPropertyGroup;
	public List<IClassMember> Members = new List<IClassMember>();
	public List<string>       Errors  = new List<string>();

	public override IEnumerable<ITree> GetNodes() { return Members; }

	public override void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

static Action<BaseRenderer,Field> WriteField;

public partial class Field : MemberBase
{
	public bool   IsStatic;
	public bool   IsReadonly;
	public string InitValue;

	public Field()
	{
	}

	public Field(string type, string name)
	{
		Type = type;
		Name = name;
	}
}

static Action<BaseRenderer, Event> WriteEvent;

public partial class Event : MemberBase
{
	public bool IsStatic;
	public bool IsVirtual;

	public Event()
	{
	}

	public Event(string type, string name)
	{
		Type = type;
		Name = name;
	}
}

static Action<BaseRenderer,Property,bool> WriteProperty;

public partial class Property : MemberBase
{
	public bool         IsAuto    = true;
	public string       InitValue;
	public bool         IsVirtual;
	public bool         IsOverride;
	public bool         IsAbstract;
	public bool         IsStatic;
	public bool         HasGetter = true;
	public bool         HasSetter = true;
	public List<string> GetBody   = new List<string>();
	public List<string> SetBody   = new List<string>();

	public int GetterLen = 5;
	public int SetterLen = 5;

	public Property()
	{
	}

	public Property(string type, string name, IEnumerable<string> getBody = null, IEnumerable<string> setBody = null)
	{
		Type = type;
		Name = name;

		InitBody(getBody, setBody);
	}

	public Property InitBody(IEnumerable<string> getBody = null, IEnumerable<string> setBody = null)
	{
		IsAuto = getBody == null && setBody == null;

		if (getBody != null) GetBody.AddRange(getBody);
		if (setBody != null) SetBody.AddRange(setBody);

		if (!IsAuto)
		{
			HasGetter = getBody != null;
			HasSetter = setBody != null;
		}

		return this;
	}

	public Property InitGetter(params string[] getBody)
	{
		return InitBody(getBody, null);
	}
}

static Action<BaseRenderer,Method,bool> WriteMethod;

public partial class Method : MemberBase
{
	public bool         IsAbstract;
	public bool         IsVirtual;
	public bool         IsOverride;
	public bool         IsStatic;
	public List<string> AfterSignature = new List<string>();
	public List<string> Parameters     = new List<string>();
	public List<string> Body           = new List<string>();

	public Method()
	{
	}

	public Method(string type, string name, IEnumerable<string> parameters = null, IEnumerable<string> body = null)
	{
		Type = type;
		Name = name;

		if (parameters != null) Parameters.AddRange(parameters);
		if (body       != null) Body.      AddRange(body);
	}
}

static Action<BaseRenderer,Attribute> WriteAttribute;

public partial class Attribute
{
	public string       Name;
	public List<string> Parameters = new List<string>();
	public string       Conditional;
	public bool         IsSeparated;

	public Attribute()
	{
	}

	public Attribute(string name, params string[] ps)
	{
		Name = name;
		Parameters.AddRange(ps);
	}
}

// Helpers.
//

Func<string,string> ToPlural   = s => s + "s";
Func<string,string> ToSingular = s => s;

static string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

public void WriteSpaces(int len)
{
	while (len-- > 0)
		Write(" ");
}

void RemoveSpace()
{
	Write(" ");

	while (GenerationEnvironment.Length > 0 &&
		(GenerationEnvironment[GenerationEnvironment.Length - 1] == ' ' ||
		 GenerationEnvironment[GenerationEnvironment.Length - 1] == '\t'))
		GenerationEnvironment.Length--;
}

public static IEnumerable<ITree> GetTreeNodes(ITree parent)
{
	foreach (var node in parent.GetNodes())
	{
		yield return node;

		foreach (var grandNode in GetTreeNodes(node))
			yield return grandNode;
	}
}

public static ITree FindNode(ITree parent, Func<ITree,bool> func)
{
	foreach (var node in parent.GetNodes())
	{
		if (func(node))
			return node;

		var n = FindNode(node, func);

		if (n != null)
			return n;
	}

	return null;
}

public static void SkipSpacesAndInsert(GeneratedTextTransformation tt, string value)
{
	var l = tt.GenerationEnvironment.Length;

	for (; l > 0 && tt.GenerationEnvironment[l - 1] == ' '; l--)
	{
	}

	tt.GenerationEnvironment.Insert(l, value);
}


string ToCamelCase(string name)
{
	var n = 0;

	foreach (var c in name)
	{
		if (char.IsUpper(c))
			n++;
		else
			break;
	}

	if (n == 0)
		return name;

	if (n == name.Length)
		return name.ToLower();

	n = Math.Max(1, n - 1);

	return name.Substring(0, n).ToLower() + name.Substring(n);
}

event Action<Property,string,object> SetPropertyValueAction;

void SetPropertyValue(Property propertyObject, string propertyName, object value)
{
	if (SetPropertyValueAction != null)
		SetPropertyValueAction(propertyObject, propertyName, value);
}

public interface IRenderer
{
	void Render(ITree model);
}

public abstract class BaseRenderer : IRenderer
{
	protected readonly GeneratedTextTransformation _tt;

	public string Indent = "\t";

	protected BaseRenderer(GeneratedTextTransformation tt)
	{
		_tt = tt;
	}

	public virtual void Render(ITree item)
	{
		if (item is ModelSource)
			RenderModelSource((ModelSource)item);
		else if (item is Namespace)
			RenderNamespace((Namespace)item);
		else if (item is TypeBase)
			RenderTypeBase((TypeBase)item);
		else if (item is MemberBase)
			RenderMemberBase((MemberBase)item);
		else 
			throw new NotImplementedException(string.Format("Unable to render {0}", item.GetType().Name));
	}

	protected virtual void RenderModelSource(ModelSource model)
	{
		if (_tt.GenerationEnvironment.Length > 0 && _tt.GenerationEnvironment.ToString().Trim().Length == 0)
			_tt.GenerationEnvironment.Length = 0;

		WriteComment("---------------------------------------------------------------------------------------------------");
		WriteComment(" <auto-generated>");
		WriteComment("    This code was generated by T4Model template for T4 (https://github.com/linq2db/linq2db).");
		WriteComment("    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
		WriteComment(" </auto-generated>");
		WriteComment("---------------------------------------------------------------------------------------------------");


		RenderUsings(model.Usings);
		WriteLine("");

		foreach (var nm in model.Namespaces)
		{
			RenderNamespace(nm);
			WriteLine("");
		}

		Trim();
	}

	protected virtual void RenderUsings(List<string> usings)
	{
		foreach (var u in usings.Distinct())
			WriteLine(u);
	}

	protected virtual void RenderNamespace(Namespace ns)
	{
		if (!string.IsNullOrEmpty(ns.Name))
		{
			BeginNamespace(ns);
			PushIndent();
		}

		RenderUsings(ns.Usings);

		foreach (var t in ns.Types)
		{
			Render(t);
			WriteLine("");
		}

		Trim();

		if (!string.IsNullOrEmpty(ns.Name))
		{
			PopIndent();
			EndNamespace(ns);
		}
	}

	protected virtual void RenderTypeBase(TypeBase typeBase)
	{
		BeginConditional(typeBase.Conditional, false);

		foreach (var c in typeBase.Comment)
			WriteComment(c);
		
		RenderAttributesWithConditional(typeBase.Attributes);

		if (typeBase is Class)
			RenderClass((Class)typeBase);
		else 
			throw new NotImplementedException(string.Format("Unable to render {0}", typeBase.GetType().Name));

		EndConditional(typeBase.Conditional, false);
	}

	protected virtual void RenderClass(Class cl)
	{
		BeginClass(cl);
		PushIndent();

		foreach (var cm in cl.Members)
			Render(cm);

		Trim();

		PopIndent();
		EndClass(cl);
	}

	protected virtual void RenderMemberBase(MemberBase member)
	{
		BeginConditional(member.Conditional, false);

		foreach (var c in member.Comment)
			WriteComment(c);
		
		RenderAttributesWithConditional(member.Attributes);

		RenderMemberBase(member, false);

		if (member.InsertBlankLineAfter)
		{
			Trim();
			WriteLine("");
		}

		EndConditional(member.Conditional, false);
	}

	protected virtual void RenderMemberBase(MemberBase member, bool isCompact)
	{
		if (member is Event)
			RenderEvent((Event)member);
		else if (member is Field)
			RenderField((Field)member);
		else if (member is Property)
			RenderProperty((Property)member, isCompact);
		else if (member is Method)
			RenderMethod((Method)member, isCompact);
		else if (member is MemberGroup)
			RenderMemberGroup((MemberGroup)member, isCompact);
		else 
			throw new NotImplementedException(string.Format("Unable to render {0}", member.GetType().Name));
	}


	protected virtual void RenderAttributesWithConditional(List<Attribute> attributes)
	{
		if (attributes.Count > 0)
		{
			var q =
				from a in attributes
				group a by a.Conditional ?? "";

			foreach (var g in q)
			{
				BeginConditional(g.Key, false);

				RenderAttributes(g);

				EndConditional(g.Key, false);
			}
		}

	}

	protected virtual void RenderAttributes(IEnumerable<Attribute> attributes)
	{
		var aa = attributes.Where(a => !a.IsSeparated).ToList();

		if (aa.Count > 0)
		{
			BeginAttributes();

			for (var i = 0; i < aa.Count; i++)
			{
				if (i > 0) SplitAttributes();
				RenderAttribute(aa[i]);
			}

			EndAttributes();
			WriteLine("");
		}

		aa = attributes.Where(a => a.IsSeparated).ToList();

		foreach (var a in aa)
		{
			BeginAttributes();
			RenderAttribute(a);
			EndAttributes();
			WriteLine("");
		}
	}

	protected abstract void BeginNamespace(Namespace ns);
	protected abstract void EndNamespace  (Namespace ns);

	protected abstract void BeginConditional(string condition, bool isCompact);
	protected abstract void EndConditional  (string condition, bool isCompact);

	protected abstract void BeginAttributes();
	protected abstract void EndAttributes  ();
	protected abstract void SplitAttributes();
	protected abstract void RenderAttribute(Attribute attributes);

	protected abstract void BeginClass(Class cl);
	protected abstract void EndClass  (Class cl);

	protected abstract void RenderEvent(Event ev);

	protected abstract void RenderField(Field fl);

	protected abstract void RenderProperty(Property pt, bool isCompact);

	protected abstract void RenderMethod(Method mt, bool isCompact);

	protected abstract void RenderMemberGroup(MemberGroup mg, bool isCompact);

	#region Tools

	public void WriteLine(string format, params object[] args)
	{
		if (args.Length > 0)
			_tt.WriteLine(format, args);
		else
			_tt.WriteLine(format);
	}
	
	public void Write(string format, params object[] args)
	{
		if (args.Length > 0)
			_tt.Write(format, args);
		else
			_tt.Write(format);
	}

	public void WriteSpaces(int count)
	{
		_tt.WriteSpaces(count);
	}

	public virtual void WriteComment(string comment)
	{
		WriteLine("//{0}", comment);
	}

	public void Trim()
	{
		var arr = new[] { '\r', '\n', ' ' };
		while (_tt.GenerationEnvironment.Length > 0 && arr.Contains(_tt.GenerationEnvironment[_tt.GenerationEnvironment.Length - 1]))
			_tt.GenerationEnvironment.Length--;

		WriteLine("");
	}

	public void PushIndent()
	{
		_tt.PushIndent(Indent);
	}

	public void PopIndent()
	{
		_tt.PopIndent();
	}

	public void RemoveSpace()
	{
		_tt.RemoveSpace();
	}

	public StringBuilder GenerationEnvironment
	{
		get { return _tt.GenerationEnvironment; }
	}

	public void SkipSpacesAndInsert(string value)
	{
		GeneratedTextTransformation.SkipSpacesAndInsert(_tt, value);
	}

	public void Error(string error)
	{
		_tt.Error(error);
	}

	#endregion
}

public class CSharpRenderer : BaseRenderer
{
	public Action<BaseRenderer,string>    WriteUsing          = (tt,s) => tt.WriteLine("using {0};", s);
	public Action<BaseRenderer,string>    WriteBeginNamespace = (tt,s) => { tt.WriteLine("namespace {0}", s); tt.WriteLine("{"); };
	public Action<BaseRenderer>           WriteEndNamespace   =  tt    => tt.WriteLine("}");
	public Action<BaseRenderer,Attribute> WriteAttribute      = (tt,a) =>
	{
		tt.Write(a.Name);

		if (a.Parameters.Count > 0)
		{
			tt.Write("(");

			for (var i = 0; i < a.Parameters.Count; i++)
			{
				if (i > 0)
					if (a.Parameters[i - 1].All(c => c == ' '))
						tt.Write("  ");
					else
						tt.SkipSpacesAndInsert(", ");
				tt.Write(a.Parameters[i]);
			}

			tt.SkipSpacesAndInsert(")");
		}
	};

	public Action<BaseRenderer,Class> WriteBeginClass = (tt,cl) =>
	{
		tt.Write(cl.AccessModifier.ToString().ToLower() + " ");
		if (cl.IsStatic)  tt.Write("static ");
		if (cl.IsPartial) tt.Write("partial ", cl.Name);
		tt.Write("class {0}", cl.Name);

		if (!string.IsNullOrEmpty(cl.BaseClass) || cl.Interfaces.Count > 0)
		{
			var arr = new[] { cl.BaseClass }.Concat(cl.Interfaces)
				.Where(n => n != null)
				.ToArray();

			tt.Write(" : ");
			tt.Write(string.Join(", ", arr));
		}

		tt.WriteLine("");
		tt.WriteLine("{");
	};

	public Action<BaseRenderer> WriteEndClass = tt => tt.WriteLine("}");

	public Action<BaseRenderer,Event> WriteEvent = (tt,m) =>
	{
		var am  = m.AccessModifier.ToString().ToLower();
		var mdf =
			(m.IsStatic  ? " static"  : "") +
			(m.IsVirtual ? " virtual" : "") +
			" event";

		tt.Write("{0}{1}{2}{3} {4}{5} {6};",
			am,     LenDiff(m.AccessModifierLen, am),
			mdf,    LenDiff(m.ModifierLen,       mdf),
			m.Type, LenDiff(m.TypeLen,           m.Type),
			m.Name);

		if (!string.IsNullOrEmpty(m.EndLineComment))
		{
			tt.WriteSpaces(m.NameLen - m.Name.Length + m.BodyLen + m.ParamLen - 1);
			tt.Write(" ");
			tt.WriteComment(" " + m.EndLineComment);
		}
		else
			tt.WriteLine("");
	};

	public Action<BaseRenderer,Field> WriteField = (tt,f) =>
	{
		var am = f.AccessModifier.ToString().ToLower();
		var mdf =
			(f.IsStatic   ? " static"   : "") +
			(f.IsReadonly ? " readonly" : "") ;

		tt.Write("{0}{1}{2}{3} {4}{5} {6}",
			am,     LenDiff(f.AccessModifierLen, am),
			mdf,    LenDiff(f.ModifierLen,       mdf),
			f.Type, LenDiff(f.TypeLen,           f.Type),
			f.Name);

		if (f.InitValue != null)
		{
			tt.Write(" = {0}", f.InitValue);
		}

		tt.Write(";");

		if (!string.IsNullOrEmpty(f.EndLineComment))
		{
			tt.WriteSpaces(f.NameLen - f.Name.Length + f.BodyLen + f.ParamLen - 1);
			tt.Write(" ");
			tt.WriteComment(" " + f.EndLineComment);
		}
		else
			tt.WriteLine("");
	};

	public Action<BaseRenderer, Property, bool> WriteProperty = (tt, p, compact) =>
	{
		var am = p.AccessModifier.ToString().ToLower();
		//	var mdf = p.IsVirtual ? " virtual" : "";
		var mdf = p.IsAbstract ? " abstract"  :
			      p.IsVirtual  ? " virtual"   :
			      p.IsOverride ? " override"  :
			      p.IsStatic   ? " static"    : "";

		tt.Write("{0}{1}{2}{3} {4}{5} {6}",
			am,     LenDiff(p.AccessModifierLen, am),
			mdf,    LenDiff(p.ModifierLen,       mdf),
			p.Type, LenDiff(p.TypeLen,           p.Type),
			p.Name);

		Action writeComment = () =>
		{
			if (!string.IsNullOrEmpty(p.EndLineComment))
			{
				tt.Write(" ");
				tt.WriteComment(" " + p.EndLineComment);
			}
			else
				tt.WriteLine("");
		};

		if (p.IsAuto)
		{
			tt.Write(LenDiff(p.NameLen + p.ParamLen, p.Name));

			var len = tt.GenerationEnvironment.Length;

			tt.Write(" { ");

			if (!p.HasGetter)
				tt.Write("private ");
			else if (p.GetterLen == 13)
				tt.Write("        ");
			tt.Write("get; ");

			if (!p.HasSetter)
				tt.Write("private ");
			else if (p.SetterLen == 13)
				tt.Write("        ");
			tt.Write("set; ");

			tt.Write("}");

			if (!string.IsNullOrEmpty(p.EndLineComment))
				tt.WriteSpaces(p.BodyLen - (tt.GenerationEnvironment.Length - len));
			writeComment();
		}
		else
		{
			if (compact)
			{
				tt.Write(LenDiff(p.NameLen + p.ParamLen, p.Name));

				var len = tt.GenerationEnvironment.Length;

				tt.Write(" { ");

				if (p.HasGetter)
				{
					tt.Write("get { ");
					foreach (var t in p.GetBody)
						tt.Write("{0} ", t);
					tt.Write("} ");
				}

				if (p.HasSetter)
				{
					tt.Write("set { ");
					foreach (var t in p.SetBody)
						tt.Write("{0} ", t);
					tt.Write("} ");
				}

				tt.Write("}");

				if (!string.IsNullOrEmpty(p.EndLineComment))
					tt.WriteSpaces(p.BodyLen - (tt.GenerationEnvironment.Length - len));
				writeComment();
			}
			else
			{
				writeComment();

				tt.WriteLine("{");
				tt.PushIndent();

				if (p.HasGetter)
				{
					if (p.GetBody.Count == 1)
					{
						tt.WriteLine("get {{ {0} }}", p.GetBody[0]);
					}
					else
					{
						tt.WriteLine("get");
						tt.WriteLine("{");
						tt.PushIndent();

						foreach (var t in p.GetBody)
							tt.WriteLine(t);

						tt.PopIndent();
						tt.WriteLine("}");
					}
				}

				if (p.HasSetter)
				{
					if (p.SetBody.Count == 1)
					{
						tt.WriteLine("set {{ {0} }}", p.SetBody[0]);
					}
					else
					{
						tt.WriteLine("set");
						tt.WriteLine("{");
						tt.PushIndent();

						foreach (var t in p.SetBody)
							tt.WriteLine(t);

						tt.PopIndent();
						tt.WriteLine("}");
					}
				}

				tt.PopIndent();
				tt.WriteLine("}");
			}
		}
	};

	public Action<BaseRenderer, Method, bool> WriteMethod = (tt, m, compact) =>
	{
		var am1  = m.AccessModifier.ToString().ToLower();
		var len1 = m.AccessModifierLen;
		var am2  = "";
		var len2 = 0;
		var mdf  = m.IsAbstract ? " abstract" :
			       m.IsVirtual  ? " virtual"  :
			       m.IsOverride ? " override" :
			       m.IsStatic   ? " static"   : "";
		var mlen = m.ModifierLen;

		if (am1 == "partial" && mdf.Length > 0)
		{
			am2 = " " + am1;
			len2 = len1 + 1;
			am1 = "";
			len1 = 0;
			mdf = mdf.Trim();
			mlen--;
		}

		tt.Write("{0}{1}{2}{3}{4}{5}{6}{7}{8} {9}",
			am1, LenDiff(len1, am1),
			mdf, LenDiff(mlen, mdf),
			am2, LenDiff(len2, am2),
			m.Type == null ? "" : " ",
			m.Type, LenDiff(m.TypeLen, m.Type ?? ""),
			m.Name);

		Action writeComment = () =>
		{
			if (!string.IsNullOrEmpty(m.EndLineComment))
			{
				tt.Write(" ");
				tt.WriteComment(" " + m.EndLineComment);
			}
			else
				tt.WriteLine("");
		};

		Action writeParams = () =>
		{
			tt.Write("(");

			for (int i = 0; i < m.Parameters.Count; i++)
			{
				if (i > 0)
					tt.Write(", ");
				tt.Write(m.Parameters[i]);
			}

			tt.Write(")");
		};

		if (compact)
		{
			tt.Write(LenDiff(m.NameLen, m.Name));

			var len = tt.GenerationEnvironment.Length;

			writeParams();

			foreach (var s in m.AfterSignature)
			{
				tt.Write(" ");
				tt.Write(s);
			}

			len = tt.GenerationEnvironment.Length - len;

			if (m.IsAbstract || m.AccessModifier == AccessModifier.Partial)
			{
				tt.Write(";");
				len = 0;
			}
			else
			{
				tt.WriteSpaces(m.ParamLen - len);

				len = tt.GenerationEnvironment.Length;

				tt.Write(" {");

				foreach (var t in m.Body)
					tt.Write(" {0}", t);

				tt.Write(" }");
			}

			if (!string.IsNullOrEmpty(m.EndLineComment))
				tt.WriteSpaces(m.BodyLen - (tt.GenerationEnvironment.Length - len));
			writeComment();
		}
		else
		{
			writeParams();
			writeComment();

			tt.PushIndent();
			foreach (var s in m.AfterSignature)
				tt.WriteLine(s);
			tt.PopIndent();

			tt.WriteLine("{");
			tt.PushIndent();

			foreach (var t in m.Body)
			{
				if (t.Length > 1 && t[0] == '#')
				{
					tt.RemoveSpace();
				}

				tt.WriteLine(t);
			}

			tt.PopIndent();
			tt.WriteLine("}");
		}
	};

	public Action<BaseRenderer,string> BeginRegion = (tt,s) => { tt.WriteLine("#region {0}", s); };
	public Action<BaseRenderer>        EndRegion   = (tt)   => { tt.WriteLine("#endregion");     };

	private bool _generateProcedureErrors;

	public CSharpRenderer(GeneratedTextTransformation tt)
		: base(tt)
	{
		_generateProcedureErrors = tt.GenerateProcedureErrors;
	}

	protected override void RenderUsings(List<string> usings)
	{
		var q =
			from ns in usings.Distinct()
			group ns by ns.Split('.')[0];

		var groups =
			(from ns in q where ns.Key == "System"                select ns).Concat
				(from ns in q where ns.Key != "System" orderby ns.Key select ns);

		foreach (var gr in groups)
		{
			foreach (var ns in from s in gr orderby s select s)
				WriteUsing(this, ns);

			WriteLine("");
		}

		Trim();
	}

	protected override void RenderAttribute(Attribute attribute)
	{
		WriteAttribute(this, attribute);
	}

	protected override void BeginNamespace(Namespace ns)
	{
		WriteBeginNamespace(this, ns.Name);
	}

	protected override void EndNamespace(Namespace ns)
	{
		WriteEndNamespace(this);
	}

	protected override void BeginConditional(string condition, bool isCompact)
	{
		if (!string.IsNullOrEmpty(condition))
		{
			RemoveSpace();
			WriteLine("#if " + condition);
			if (!isCompact) WriteLine("");
		}
	}

	protected override void EndConditional(string condition, bool isCompact)
	{
		if (!string.IsNullOrEmpty(condition))
		{
			Trim();
			if (!isCompact) WriteLine("");
			RemoveSpace();
			WriteLine("#endif");
			if (!isCompact) WriteLine("");
		}
	}

	protected override void BeginAttributes() { Write("["); }
	protected override void EndAttributes  () { Write("]"); }
	protected override void SplitAttributes() { SkipSpacesAndInsert(", "); }

	protected override void BeginClass(Class cl) { WriteBeginClass(this, cl); }
	protected override void EndClass  (Class cl) { WriteEndClass(this); }
	
	protected override void RenderEvent(Event ev) { WriteEvent(this, ev); }
	
	protected override void RenderField(Field fl) { WriteField(this, fl); }

	protected override void RenderProperty(Property pt, bool isCompact)
	{
		if (!pt.IsAuto && pt.HasGetter && pt.GetBody.Count == 1)
		{
			var t = pt.GetBody[pt.GetBody.Count - 1];

			if (!t.StartsWith("return"))
			{
				t = "return " + t;

				if (!t.EndsWith(";"))
					t += ";";

				pt.GetBody[pt.GetBody.Count - 1] = t;
			}
		}

		WriteProperty(this, pt, isCompact);
	}

	public int CalcModifierLen(MemberBase member)
	{
		if (member is Field)
		{
			var f = (Field)member;
			return
				(f.IsStatic   ? " static".  Length : 0) +
				(f.IsReadonly ? " readonly".Length : 0) ;
		}

		if (member is Event)
		{
			var e = (Event)member;
			return
				(e.IsStatic  ? " static". Length : 0) +
				(e.IsVirtual ? " virtual".Length : 0) +
				" event".Length;
		}

		if (member is Property)
		{
			var p = (Property)member;
			return p.IsVirtual ? " virtual".Length : 0;
		}

		if (member is Method)
		{
			var m = (Method)member;
			return
				m.IsAbstract ? " abstract".Length :
				m.IsVirtual  ? " virtual".Length  :
				m.IsStatic   ? " static".Length   : 0;
		}

		return 0;
	}

	public int CalcBodyLen(MemberBase member)
	{
		if (member is MemberGroup)
			return 0;

		if (member is Field)
		{
			var f = (Field)member;
			return f.InitValue == null ? 1 : 4 + f.InitValue.Length;
		}

		if (member is Event)
		{
			return 1;
		}

		if (member is Property)
		{
			var p = (Property)member;

			if (p.IsAuto)
				return 4 + p.GetterLen + p.SetterLen; // ' { get; set; }'

			var len = " {".Length;

			if (p.HasGetter)
			{
				len += " get {".Length;
				foreach (var t in p.GetBody)
					len += 1 + t.Length;
				len += " }".Length;
			}

			if (p.HasSetter)
			{
				len += " set {".Length;
				foreach (var t in p.SetBody)
					len += 1 + t.Length;
				len += " }".Length;
			}

			len += " }".Length;

			return len;

		}

		if (member is Method)
		{
			var m = (Method)member;
			if (m.IsAbstract || m.AccessModifier == AccessModifier.Partial)
				return 1;

			var len = " {".Length;

			foreach (var t in m.Body)
				len += 1 + t.Length;

			len += " }".Length;

			return len;

		}

		throw new NotImplementedException(string.Format("CalcBodyLen is not implemented for {0}", member.GetType().Name));
	}

	public int CalcParamLen(MemberBase member)
	{
		
		if (member is Method)
		{
			var m = (Method)member;
			return m.Parameters.Sum(p => p.Length + 2);
		}

		return 0;
	}

	protected override void RenderMethod(Method mt, bool isCompact)
	{
		WriteMethod(this, mt, isCompact);
	}

	protected virtual void RenderMemberBase(MemberBase member)
	{
		if (member is MemberGroup)
			RenderMemberGroup((MemberGroup)member, false);
		else
			base.RenderMemberBase(member);
	}

	protected override void RenderMemberGroup(MemberGroup mg, bool isCompact)
	{
		BeginConditional(mg.Conditional, isCompact);

		if (!string.IsNullOrEmpty(mg.Region))
		{
			BeginRegion(this, mg.Region);
			WriteLine("");
		}

		if (mg.Errors.Count > 0 && _generateProcedureErrors)
		{
			RemoveSpace();
			WriteComment(" Use 'GenerateProcedureErrors=false' to disable errors.");
			foreach (var error in mg.Errors)
			{
				Error(error);

				foreach (var e in error.Split('\n'))
				{
					RemoveSpace();
					WriteLine("#error " + e.Trim('\r'));
				}
			}

			WriteLine("");
		}

		if (mg.IsCompact)
		{
			var allMembers = GetTreeNodes(mg).OfType<MemberBase>().Where(m => !(m is MemberGroup)).ToList();

			if (allMembers.Count > 0)
			{
				int max = allMembers.Max(m => m.AccessModifier.ToString().Length);
				foreach (var m in allMembers)
					m.AccessModifierLen = max;

				max = allMembers.Max(m => CalcModifierLen(m));
				foreach (var m in allMembers)
					m.ModifierLen = max;

				max = allMembers.Max(m => (m.Type ?? "").Length);
				foreach (var m in allMembers)
					m.TypeLen = max;

				var notHasGetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasGetter);
				var notHasSetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasSetter);

				foreach (var p in allMembers.OfType<Property>())
				{
					if (notHasGetter) p.GetterLen = 13;
					if (notHasSetter) p.SetterLen = 13;
				}

				max = allMembers.Max(m => m.Name.Length);
				foreach (var m in allMembers)
					m.NameLen = max;

				max = allMembers.Max(m => CalcParamLen(m));
				foreach (var m in allMembers)
					m.ParamLen = max;

				max = allMembers.Max(m => CalcBodyLen(m));
				foreach (var m in allMembers)
					m.BodyLen = max;

				var members =
				(
					from m in allMembers
					select new
					{
						m,
						attrs =
						(
							from a in m.Attributes
							group a by a.Name into gr
							select gr.Select((a,i) => new { a, name = a.Name + "." + i }).ToList() into s
							from a in s
							select a
						).ToList()
					}
				).ToList();

				var attrWeight =
				(
					from m in members
					from a in m.attrs
					group a by a.name into gr
					select new { gr.Key, Count = gr.Count() }
				).ToDictionary(a => a.Key, a => a.Count);

				var q =
					from m in members
					where m.attrs.Count > 0
					select new { m, w = m.attrs.Sum(aa => attrWeight[aa.name]) } into m
					orderby m.w descending
					select m.m;

				var attrs = new List<string>();

				foreach (var m in q)
				{
					var list = m.attrs.Select(a => a.name).ToList();

					if (attrs.Count == 0)
						attrs.AddRange(list);
					else
					{
						for (var i = 0; i < list.Count; i++)
						{
							var nm = list[i];

							if (!attrs.Contains(nm))
							{
								for (var j = i + 1; j < list.Count; j++)
								{
									var idx = attrs.IndexOf(list[j]);

									if (idx >= 0)
									{
										attrs.Insert(idx, nm);
										break;
									}
								}
							}

							if (!attrs.Contains(nm))
								attrs.Add(nm);
						}
					}
				}

				var mms = members.Select(m =>
				{
					var arr = new Attribute[attrs.Count];

					foreach (var a in m.attrs)
						arr[attrs.IndexOf(a.name)] = a.a;

					return new { m.m, attrs = arr.ToList() };
				}).ToList();

				var idxs = Enumerable.Range(0, attrs.Count).Select(_ => new List<int>()).ToList();

				for (var i = 0; i < mms.Count; i++)
					for (var j = 0; j < mms[i].attrs.Count; j++)
						if (mms[i].attrs[j] != null)
							idxs[j].Add(i);

				var toRemove = new List<int>();

				for (int i = 1; i < idxs.Count; i++)
				{
					for (int j = 0; j < i; j++)
					{
						if (idxs[j] == null)
							continue;

						if (idxs[i].Intersect(idxs[j]).Count() == 0)
						{
							foreach (var m in mms)
							{
								if (m.attrs[i] != null)
								{
									m.attrs[j] = m.attrs[i];
									m.attrs[i] = null;
								}
							}

							idxs[j].AddRange(idxs[i]);
							idxs[i] = null;
							toRemove.Add(i);
							break;
						}
					}

				}

				foreach (var n in toRemove.OrderByDescending(i => i))
					foreach (var m in mms)
						m.attrs.RemoveAt(n);

				var lens = new int[attrs.Count - toRemove.Count];

				foreach (var m in mms)
				{
					for (var i = 0; i < m.attrs.Count; i++)
					{
						var a = m.attrs[i];

						if (a != null)
						{
							var len = a.Name.Length;

							if (a.Parameters.Count >= 0)
								len += a.Parameters.Sum(p => 2 + p.Length);

							lens[i] = Math.Max(lens[i], len);
						}
					}
				}

				foreach (var m in allMembers)
				{
					if (!(m is MemberGroup))
						BeginConditional(m.Conditional, mg.IsCompact);

					foreach (var c in m.Comment)
						WriteComment(c);

					if (attrs.Count > 0)
					{
						var ma = mms.First(mr => mr.m == m);

						if (m.Attributes.Count > 0)
						{
							Write("[");

							for (var i = 0; i < ma.attrs.Count; i++)
							{
								var a = ma.attrs[i];

								if (a == null)
								{
									WriteSpaces(lens[i]);
									if (i + 1 < ma.attrs.Count)
										Write("  ");
								}
								else
								{
									var len = GenerationEnvironment.Length;
									RenderAttribute(a);
									len = (GenerationEnvironment.Length - len);

									var commaAdded = false;

									for (var j = i + 1; j < ma.attrs.Count; j++)
									{
										if (ma.attrs[j] != null)
										{
											SkipSpacesAndInsert(", ");
											commaAdded = true;
											break;
										}
									}

									if (i + 1 < ma.attrs.Count && !commaAdded)
										Write("  ");

									WriteSpaces(lens[i] - len);
								}
							}

							Write("] ");
						}
						else
						{
							WriteSpaces(lens.Sum() + ma.attrs.Count * 2 + 1);
						}
					}

					RenderMemberBase(m, true);

					if (!mg.IsCompact)
						WriteLine("");

					if (!(m is MemberGroup))
						EndConditional(m.Conditional, mg.IsCompact);
				}
			}
		}
		else
		{
			foreach (var cm in mg.Members)
			{
				if (cm is MemberBase)
				{
					var m = (MemberBase)cm;

					if (!(m is MemberGroup))
						BeginConditional(m.Conditional, mg.IsCompact);

					foreach (var c in m.Comment)
						WriteComment(c);

					if (m.Attributes.Count > 0)
					{
						var q =
							from a in m.Attributes
							group a by a.Conditional ?? "";

						foreach (var g in q)
						{
							if (g.Key.Length > 0)
							{
								RemoveSpace();
								WriteLine("#if " + g.Key);
							}

							var attrs = g.ToList();

							var aa = attrs.Where(a => !a.IsSeparated).ToList();

							if (aa.Count > 0)
							{
								Write("[");

								for (var i = 0; i < aa.Count; i++)
								{
									if (i > 0) Write(", ");
									RenderAttribute(aa[i]);
								}

								WriteLine("]");
							}

							aa = attrs.Where(a => a.IsSeparated).ToList();

							foreach (var a in aa)
							{
								Write("[");
								RenderAttribute(a);
								WriteLine("]");
							}

							if (g.Key.Length > 0)
							{
								RemoveSpace();
								WriteLine("#endif");
							}
						}
					}

					RenderMemberBase(m, false);

					if (m.InsertBlankLineAfter)
					{
						Trim();
						WriteLine("");
					}

					if (!(m is MemberGroup))
						EndConditional(m.Conditional, mg.IsCompact);
				}
				else if (cm is TypeBase)
				{
					var t = (TypeBase)cm;

					RenderTypeBase(t);
					WriteLine("");
				}
			}
		}

		Trim();

		EndConditional(mg.Conditional, isCompact);

		if (!string.IsNullOrEmpty(mg.Region))
		{
			WriteLine("");
			EndRegion(this);
		}
	}
}
#>
